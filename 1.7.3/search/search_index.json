{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification. </p>"},{"location":"client_configuration/","title":"Client-side configuration properties","text":"<p>Note: if you are using Quarkus, it is recommended to use the <code>quarkus.*</code> property counterparts instead.  See Quarkus Documentation for more info. </p> Property Default value Meaning <code>CLIENT_NAME/mp-graphql/url</code> none Denotes URL to connect to <code>CLIENT_NAME/mp-graphql/header/KEY</code> none Adds a HTTP header named <code>KEY</code> to all HTTP requests performed by the client <code>CLIENT_NAME/mp-graphql/subprotocols</code> <code>graphql-ws,graphql-transport-ws</code> Comma-separated list of websocket subprotocols supported by this client. We currently support <code>graphql-ws</code> and <code>graphql-transport-ws</code>. If multiple subprotocols are provided, choosing the actual subprotocol will be subject to negotiation with the server. <code>CLIENT_NAME/mp-graphql/keystore</code> none Path to client's keystore (for example <code>file:/path/to/keystore</code> or <code>classpath:path/to/keystore</code>) <code>CLIENT_NAME/mp-graphql/keystoreType</code> <code>JKS</code> Keystore type <code>CLIENT_NAME/mp-graphql/keystorePassword</code> none Keystore password <code>CLIENT_NAME/mp-graphql/truststore</code> none Path to client's truststore (for example <code>file:/path/to/truststore</code> or <code>classpath:path/to/truststore</code>) <code>CLIENT_NAME/mp-graphql/truststoreType</code> <code>JKS</code> Truststore type <code>CLIENT_NAME/mp-graphql/truststorePassword</code> none Truststore password <code>CLIENT_NAME/mp-graphql/proxyHost</code> none Hostname of the proxy to use <code>CLIENT_NAME/mp-graphql/proxyPort</code> none Port of the proxy to use <code>CLIENT_NAME/mp-graphql/proxyUsername</code> none Username for the proxy to use <code>CLIENT_NAME/mp-graphql/proxyPassword</code> none Password for the proxy to use <code>CLIENT_NAME/mp-graphql/maxRedirects</code> 16 Max number of redirects to follow. Set to 0 to disable redirects. <code>CLIENT_NAME/mp-graphql/websocketInitializationTimeout</code> none Maximum time in milliseconds that will be allowed to wait for the server to acknowledge a websocket connection. <code>CLIENT_NAME/mp-graphql/runSingleOperationsOverWebsocket</code> <code>false</code> If true, then queries and mutations will run over the websocket transport rather than pure HTTP. Off by default, because it has higher overhead."},{"location":"custom-error-extensions/","title":"GraphQL Error Extensions","text":"<p>Exceptions are reported in GraphQL in the <code>errors</code> array, next to the <code>data</code> field, so it's possible to return partial results, e.g.:</p> <pre><code>{\n  \"data\": {\n    \"superHero\": {\n      \"name\": \"Wolverine\",\n      \"location\": null\n    }\n  },\n  \"errors\": [{\n    \"message\":\"location unknown\",\n    \"path\": [\"superHero\",\"location\"],\n    \"extensions\":{\"code\":\"location-unknown\"}\n  }]\n}\n</code></pre> <p>The <code>location</code> field couldn't be returned, and in the <code>errors</code>, there's the reason with a few predefined fields, and a map of <code>extensions</code> that can contain custom details about the error.</p> <p>You can add your own extensions by implementing the <code>io.smallrye.graphql.api.ErrorExtensionProvider</code> interface and adding your class name to a file <code>META-INF/services/io.smallrye.graphql.api.ErrorExtensionProvider</code> (this is a <code>ServiceLoader</code>).</p> <p>As an example, this class provides an extension named <code>exception-length</code> with the length of the simple class name of the exception:</p> <pre><code>public class ExceptionLengthErrorExtensionProvider implements ErrorExtensionProvider {\n    @Override\n    public String getKey() {\n        return \"exception-length\";\n    }\n\n    @Override\n    public JsonNumber mapValueFrom(Throwable exception) {\n        return Json.createValue(exception.getClass().getSimpleName().length());\n    }\n}\n</code></pre>"},{"location":"custom-json-deserializers/","title":"Customizing JSON-B deserializers","text":"<p>If your application needs finer-grained control over JSON deserialization than you can achieve via formatting annotations like <code>@JsonbDateFormat</code>, you may plug in your own custom instances of the <code>Jsonb</code> class for each input type that your GraphQL application exposes.</p> <p>To do this, you'll need to create an implementation of <code>io.smallrye.graphql.spi.EventingService</code> and implement its <code>overrideJsonbConfig</code> method.  An example that plugs in a custom date format for a particular class that is used as input:</p> <pre><code>public class CustomJsonbService implements EventingService {\n\n    @Override\n    public String getConfigKey() {\n        return null; // activate this service always regardless of the configuration \n    }\n\n    @Override\n    public Map&lt;String, Jsonb&gt; overrideJsonbConfig() {\n        JsonbConfig config = new JsonbConfig().withDateFormat(\"MM dd yyyy HH:mm Z\", null);\n        return Collections.singletonMap(\"org.example.model.MyModelClass\", JsonbBuilder.create(config));\n    }\n}\n</code></pre> <p>As the discovery of eventing services uses the ServiceLoader mechanism, don't forget to add a  <code>META-INF/services/io.smallrye.graphql.spi.EventingService</code> file that contains the fully qualified  name of your implementation.</p>"},{"location":"directives/","title":"Directives","text":""},{"location":"directives/#directives-generated-from-bean-validation-annotations","title":"Directives generated from Bean Validation annotations","text":"<p>If your project uses Bean Validation to validate fields on input types and operation arguments, and you enable  inclusion of directives in the schema (by setting <code>smallrye.graphql.schema.includeDirectives=true</code>),  then constraints decoded from annotations will be added to your schema as directives. This is currently only  supported for some built-in constraints (annotations from the  <code>javax.validation.constraints</code> package), and custom constraints aren't supported at all. </p> <p>Each bean validation annotation is mapped to a single <code>@constraint</code> directive. The directive is declared as repeatable, so if you have multiple constraints on an input field, the field will contain multiple <code>@constraint</code> directives. The following table describes the mapping between BV annotations and <code>@constraint</code> directives (all currently supported  BV annotations are listed here): </p> BV annotation GraphQL directive <code>@Size(MIN, MAX)</code> <code>@constraint(minLength=MIN, maxLength=MAX)</code> <code>@Email</code> <code>@constraint(format='email')</code> <code>@Max</code> <code>@constraint(max=VALUE)</code> <code>@Min</code> <code>@constraint(min=VALUE)</code> <code>@Pattern(REGEXP)</code> <code>@constraint(pattern=REGEXP)</code> <p>Note: The <code>@NotNull</code> annotation does not map to a directive, instead it makes the GraphQL type non-nullable.</p> <p>Constraints will only appear on fields of input types and operation arguments.</p>"},{"location":"dynamic-client-error-handling/","title":"Error handling with dynamic clients","text":""},{"location":"dynamic-client-error-handling/#system-level-errors","title":"System-level errors","text":"<p>If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will (instead of returning a  <code>io.smallrye.graphql.client.Response</code>) throw a <code>io.smallrye.graphql.client.InvalidResponseException</code> whose message contains information about the received status code, status message, and body contents.</p>"},{"location":"dynamic-client-error-handling/#application-level-errors","title":"Application-level errors","text":"<p>If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty <code>errors</code> entry), the client invocation will return a <code>io.smallrye.graphql.client.Response</code> as normal, and that object will contain information about the errors. Errors are represented as <code>io.smallrye.graphql.client.GraphQLError</code> objects and can be inspected after retrieving a list of all errors using <code>response.getErrors()</code>.</p> <p>[NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of <code>errors</code>, <code>data</code> and <code>extensions</code> entries, and no other entries beyond that.</p> <p>It is also possible to convert a response's errors into a <code>io.smallrye.graphql.client.GraphQLClientException</code> by calling <code>throwExceptionIfErrors()</code> - the response has to be cast to <code>ResponseImpl</code> for this as of now. This method will, if there are any errors in the response, convert the errors into a <code>GraphQLClientException</code>  and throw it.</p> <p>If you need to access the HTTP response code and message pertaining to a response that contained application-level errors, refer to Accessing HTTP headers and response codes.</p>"},{"location":"dynamic-client-usage/","title":"Dynamic client introduction and basic usage","text":"<p>A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the <code>javax.ws.rs.client</code> package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary.</p> <p>In the current implementation, Vert.x HTTP client is used for handling the underlying traffic.</p>"},{"location":"dynamic-client-usage/#creating-a-client-instance","title":"Creating a client instance","text":"<p>Generally there are two ways to obtain a client instance.</p> <p>First, using CDI injection where the configuration values are defined in system properties:</p> <pre><code>@Inject\n@GraphQLClient(\"superheroes\")\nDynamicGraphQLClient client;\n\n// assuming that this system property exists:\n// superheroes/mp-graphql/url=https://superheroes.org/graphql\n</code></pre> <p>The above example assumes that configuration for the client is present in system properties. For a full list of supported configuration properties, see Client configuration reference</p> <p>The other way to build a client is programmatically using a builder:</p> <pre><code>DynamicGraphQLClient client = DynamicGraphQLClientBuilder.newBuilder()\n    .url(\"https://superheroes.org/graphql\")\n    .build();\n</code></pre> <p>The usage examples in the following sections will assume using the first approach - injection.</p>"},{"location":"dynamic-client-usage/#basic-usage","title":"Basic Usage","text":"<p>Given the following GraphQL service on the server side:</p> <pre><code>@GraphQLApi\nclass SuperHeroesApi {\n    @Query\n    List&lt;SuperHero&gt; allHeroesIn(String location) {\n        // ....\n    }\n}\n\nclass SuperHero {\n    private String name;\n    private List&lt;String&gt; superPowers;\n}\n</code></pre> <p>Such service can be queried this way:</p> <pre><code>package examples.dynamicclient;\n\nimport examples.typesafeclient.SuperHero;\nimport io.smallrye.graphql.client.GraphQLClient;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.core.Document;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\n\nimport javax.inject.Inject;\nimport javax.json.JsonArray;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\nimport static io.smallrye.graphql.client.core.Argument.arg;\nimport static io.smallrye.graphql.client.core.Argument.args;\nimport static io.smallrye.graphql.client.core.Document.document;\nimport static io.smallrye.graphql.client.core.Field.field;\nimport static io.smallrye.graphql.client.core.Operation.operation;\n\npublic class MyClientUsage {\n\n    @Inject\n    @GraphQLClient(\"superHeroes\")\n    DynamicGraphQLClient client;\n\n    public void execute() throws ExecutionException, InterruptedException {\n        Document document = document(   // &lt;1&gt;\n            operation(field(\"allHeroesIn\",\n                args(arg(\"location\", \"Outer Space\")),\n                field(\"name\"),\n                field(\"superPowers\"))));\n        Response response = client.executeSync(document); // &lt;2&gt;\n\n        JsonArray heroesArray = response.getData().getJsonArray(\"allHeroesIn\");  // &lt;3&gt;\n        List&lt;SuperHero&gt; heroes = response.getList(SuperHero.class, \"allHeroesIn\"); // &lt;4&gt;\n    }\n}\n</code></pre> <ul> <li> <p>&lt;1&gt; Creating the document representing the request. We used static     imports to make the code easy to read, they all come from the     classes in the <code>io.smallrye.graphql.client.core</code> package.</p> </li> <li> <p>&lt;2&gt; Executing the request. You can either do that in a blocking way, or     request a <code>Uni</code> if you prefer the reactive style.</p> </li> <li> <p>&lt;3&gt; Obtaining the resulting list of heroes as a <code>JsonArray</code>.</p> </li> <li> <p>&lt;4&gt; Obtaining the resulting list of heroes as instances of the model     class. This is optional, you can continue working with the data as a <code>JsonArray</code> if you prefer.</p> </li> </ul>"},{"location":"dynamic-client-usage/#using-plain-strings-instead-of-the-dsl","title":"Using plain strings instead of the DSL","text":"<p>If you don't like the DSL for some reason and want to use plain strings for your queries, these two examples will serve you:</p> <pre><code>package examples.dynamicclient;\n\nimport io.smallrye.graphql.client.GraphQLClient;\nimport io.smallrye.graphql.client.Response;\nimport io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient;\n\nimport javax.inject.Inject;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\n\npublic class MyClientUsageString {\n\n    @Inject\n    @GraphQLClient(\"superheroes\")\n    DynamicGraphQLClient client;\n\n    public void execute() throws ExecutionException, InterruptedException {\n        String queryWithInlineVariables =   // &lt;1&gt;\n            \"query {\" +\n            \"  allHeroesIn(location: \\\"Outer Space\\\") {\" +\n            \"    name\" +\n            \"    superPowers\" +\n            \"  }\" +\n            \"}\";\n        Response response = client.executeSync(queryWithInlineVariables);\n\n        String queryWithExtractedVariables =   // &lt;2&gt;\n            \"query($loc: String) {\" +\n            \"  allHeroesIn(location: $loc) {\" +\n            \"    name\" +\n            \"    superPowers\" +\n            \"  }\" +\n            \"}\";\n        Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); // &lt;3&gt;\n        variables.put(\"loc\", \"Outer Space\");\n        Response response2 = client.executeSync(queryWithExtractedVariables, variables);\n    }\n}\n</code></pre> <ul> <li> <p>&lt;1&gt;: In this variant, we inline values for query arguments directly into the query string.</p> </li> <li> <p>&lt;2&gt;: In this variant, argument values are extracted into variables. The <code>location</code> argument of the <code>allHeroesIn</code> query is      declared to be using the variable <code>loc</code> (the variable can also be named <code>location</code> same as the argument, if     you prefer).</p> </li> <li> <p>&lt;3&gt;: Here we create a map that defines the values for each variable. Values of this map are <code>Object</code>s,     so you can put in strings, numbers, booleans, or any object that corresponds to a GraphQL type and can be     serialized to JSON. Inserting a <code>JsonObject</code> directly is also supported.</p> </li> </ul>"},{"location":"dynamic-client-usage/#accessing-http-headers-and-response-codes","title":"Accessing HTTP headers and response codes","text":"<p>To access HTTP transport metadata that was passed by the server, you can inspect the <code>Response</code> object.</p> <p><code>Response.getTransportMeta(\"HEADER-NAME\")</code> returns a <code>List&lt;String&gt;</code> containing (potentially multiple) values of the requested header.</p> <p>To get the HTTP status code or status message, these are stored inside the <code>transportMeta</code> map too. <code>ResponseImpl</code>  contains convenience methods to retrieve them: <code>ResponseImpl.getStatusCode()</code> and <code>ResponseImpl.getStatusMessage()</code>. It's also possible to retrieve them directly without casting to <code>ResponseImpl</code> by calling <code>Integer.valueOf(response.getTransportMeta().get(\"&lt;status-code&gt;\").get(0))</code> and <code>response.getTransportMeta().get(\"&lt;status-message&gt;\").get(0)</code>.</p> <p>HTTP headers, status codes and messages are only available for operations executed over pure HTTP, not via websockets!</p>"},{"location":"gradle-plugin/","title":"SmallRye GraphQL Gradle plugin","text":"<p>This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file.</p> <p>Add this to your build.gradle:</p> <pre><code>plugins {\n    id 'io.smallrye.graphql' version '1.0.2-SNAPSHOT'\n}\n</code></pre> <p>The schema will appear as <code>build/generated/schema.graphql</code> by default.</p> <p>The plugin\u2019s <code>generateSchema</code> task can customized like:</p> <pre><code>generateSchema {\n    destination = null\n    includeTransitiveDependencies = true\n    includeScalars = true\n}\n</code></pre> <p>This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to <code>null</code> the generated schema will only be output to the console and saved to a file.</p> <p>In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like:</p> <pre><code>configrations {\n    graphQLSchema\n}\n\ndependencies {\n    graphQLSchema ..\n}\n\ngenerateSchema {\n    includeDependencies = true\n    configurations = [\"graphQLSchema\"]\n}\n</code></pre> <p>This defines a separate <code>graphQLSchema</code> configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the <code>graphQLSchema</code> configuration. The <code>generateSchema</code> task is then customized to only include dependencies from the <code>graphQLSchema</code> configuration. Also note that we set <code>includeDependencies</code> to <code>true</code> (and not <code>includeTransitiveDependencies</code>). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies.</p>"},{"location":"gradle-plugin/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>destination</code> - To override the default     <code>build/generated/schema.graphql</code> destination.</p> </li> <li> <p><code>includeDependencies</code> - Scan project\u2019s dependencies for GraphQL     model classes too. Default false.</p> </li> <li> <p><code>includeTransitiveDependencies</code> - Scan project\u2019s dependencies     (including the transitive dependencies) for GraphQL model classes     too. Default false.</p> </li> <li> <p><code>configurations</code> - If the above <code>includeDependencies</code> or     <code>includeTransitiveDependencies</code> is true, you can control what     configurations should be included. Default is <code>implementation</code>.</p> </li> <li> <p><code>dependencyExtensions</code> - If the above <code>includeDependencies</code> or     <code>includeTransitiveDependencies</code> is true, you can control what     dependency extensions should be included. Default is <code>jar</code>.</p> </li> <li> <p><code>includeScalars</code> - Include scalars in the schema. Default false.</p> </li> <li> <p><code>includeDirectives</code> - Include directives in the schema. Default     false.</p> </li> <li> <p><code>includeSchemaDefinition</code> - Include the schema definition. Default     false.</p> </li> <li> <p><code>includeIntrospectionTypes</code> - Include the introspection types in the     schema. Default false.</p> </li> </ul>"},{"location":"maven-plugin/","title":"SmallRye GraphQL Maven plugin","text":"<p>This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file.</p> <p>Add this to your pom.xml:</p> <pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;smallrye-graphql-maven-plugin&lt;/artifactId&gt;\n    &lt;groupId&gt;io.smallrye&lt;/groupId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;generate-schema&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> <p>The schema will appear as <code>target/generated/schema.graphql</code> by default. The goal is bound to the <code>process-classes</code>  build phase.</p>"},{"location":"maven-plugin/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>destination</code> - To override the default <code>target/generated/schema.graphql</code> destination</p> </li> <li> <p><code>includeDependencies</code> - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off (<code>false</code>) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. </p> </li> <li> <p><code>includeDependenciesScopes</code> - If the above <code>includeDependencies</code> is true, you can control what scopes should be included. Default is <code>compile, system</code></p> </li> <li> <p><code>includeDependenciesTypes</code> - If the above <code>includeDependencies</code> is true, you can control what types should be included. Default is <code>jar</code></p> </li> <li> <p><code>includeScalars</code> - Include scalars in the schema. Default false.</p> </li> <li> <p><code>includeDirectives</code> - Include directives in the schema. Default false.</p> </li> <li> <p><code>includeSchemaDefinition</code> - Include the schema definition. Default false.</p> </li> <li> <p><code>includeIntrospectionTypes</code> - Include the introspection types in the schema. Default false.</p> </li> <li> <p><code>typeAutoNameStrategy</code> - Strategy for transforming class names into GraphQL type names.  Valid values are <code>MergeInnerClass</code>, <code>Full</code> and<code>Default</code>.</p> </li> </ul>"},{"location":"server_configuration/","title":"Configuration properties","text":"<p>These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these,  and it is recommended to use the <code>quarkus.*</code> properties. Refer to the Quarkus documentation:  Server and Client side Quarkus properties.</p>"},{"location":"server_configuration/#from-microprofile-graphql","title":"From MicroProfile GraphQL","text":"Property Default value Meaning <code>mp.graphql.defaultErrorMessage</code> <code>Server Error</code> Error message for hidden exceptions <code>mp.graphql.hideErrorMessage</code> Runtime exceptions Exceptions that will be hidden <code>mp.graphql.showErrorMessage</code> Checked exceptions Exceptions that will not be hidden."},{"location":"server_configuration/#from-smallrye-graphql","title":"From SmallRye GraphQL","text":"Property Default value Meaning <code>smallrye.graphql.printDataFetcherException</code> <code>false</code> Include the stacktrace of the data fetching exception in the log output <code>smallrye.graphql.allowGet</code> <code>false</code> Allow HTTP GET Method <code>smallrye.graphql.metrics.enabled</code> <code>false</code> Enable metrics <code>smallrye.graphql.tracing.enabled</code> <code>false</code> Enable tracing <code>smallrye.graphql.validation.enabled</code> <code>true</code> if Bean Validation is present Enable Bean Validation. This property is DEPRECATED, setting to <code>false</code> won't actually turn off validation. It will be removed in a future release. <code>smallrye.graphql.events.enabled</code> <code>true</code> if one of metrics, tracing or bean validation is true Enable eventing <code>smallrye.graphql.logPayload</code> <code>false</code> Log the payload in the log file <code>smallrye.graphql.fieldVisibility</code> To control the field visibility on introspection <code>smallrye.graphql.schema.includeScalars</code> <code>true</code> Include Scalar definitions in the schema <code>smallrye.graphql.schema.includeSchemaDefinition</code> <code>false</code> Include Schema definition <code>smallrye.graphql.schema.includeDirectives</code> <code>false</code> Include directives in the schema <code>smallrye.graphql.schema.includeIntrospectionTypes</code> <code>false</code> Include Introspection types in the schema"},{"location":"typesafe-client-custom-scalars/","title":"Custom scalar types","text":"<p>If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings.</p> <p>A model class is considered to represent a scalar GraphQL type if it contains a static builder method named <code>of</code>, <code>valueOf</code>, or <code>parse</code> whose sole parameter is a <code>java.lang.String</code> and it returns an  instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class.</p> <p>For example, if the server supports a <code>URL</code> type (there is a <code>scalar URL</code> clause in the schema),  create a class that represents a value for <code>URL</code>:</p> <pre><code>public class URL {\n\n    private String value;\n\n    public URL(String value) {\n        this.value = value;\n    }\n\n    public static URL valueOf(String value) {  // &lt;1&gt;\n        return new URL(value);\n    }\n\n    @Override\n    public String toString() {   // &lt;2&gt;\n        return value;\n    }\n}\n</code></pre> <ul> <li>&lt;1&gt; The static <code>valueOf(String)</code> method will be used for deserializing a <code>URL</code> from a string.</li> <li>&lt;2&gt; The <code>toString()</code> will be used for serializing a <code>URL</code> into a string to be sent to the GraphQL service</li> </ul>"},{"location":"typesafe-client-error-handling/","title":"Error handling in typesafe clients","text":""},{"location":"typesafe-client-error-handling/#system-level-errors","title":"System-level errors","text":"<p>If the service returns a system-level error (which means the response body doesn't contain a valid GraphQL response document), the client invocation will throw a <code>io.smallrye.graphql.client.InvalidResponseException</code> whose message contains information about the received status code, status message, and body contents.</p>"},{"location":"typesafe-client-error-handling/#application-level-errors","title":"Application-level errors","text":"<p>If the service returns one or more application-level errors (which means that there is valid GraphQL response in the body that has a non-empty <code>errors</code> entry),  the client normally throws a <code>GraphQLClientException</code> containing the details in a list of <code>GraphQLClientError</code>.</p> <p>[NOTE] An error response is considered application-level regardless of the HTTP status code as long as it contains a valid GraphQL response. We define a GraphQL response as a well-formed JSON document that contains at least one of <code>errors</code>, <code>data</code> and <code>extensions</code> entries, and no other entries beyond that.</p> <p>If the error is specific to a <code>location</code>, you can use an <code>ErrorOr</code> wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your <code>SuperHero</code> class could look like this:</p> <pre><code>class SuperHero {\n    String name;\n    ErrorOr&lt;Location&gt; location;\n}\n</code></pre> <p>If the service returns a response like this:</p> <pre><code>{\n  \"data\": {\n    \"superHero\": {\n      \"name\": \"Wolverine\",\n      \"location\": null\n    }\n  },\n  \"errors\": [{\n    \"message\":\"location unknown\",\n    \"path\": [\"superHero\",\"location\"],\n    \"extensions\":{\"code\":\"location-unknown\"}\n  }]\n}\n</code></pre> <p>Then the <code>SuperHero#location</code> wrapper field will not contain a <code>value</code> but only the error above. See the <code>ErrorOr</code> class for details.</p>"},{"location":"typesafe-client-headers/","title":"Adding headers","text":"<p>To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as <code>@Header</code>, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    @Header(name = \"S.H.I.E.L.D.-Clearance\", constant = \"TOP-SECRET\")\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n}\n</code></pre> <p>The value can be specified with a <code>constant</code> or the name of a <code>method</code> for dynamic values, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"establishShieldClearance\")\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n\n    static Clearance establishShieldClearance() { \n        return userIsInRole(MANAGER) ? TOP_SECRET : PUBLIC;\n    }\n}\n</code></pre> <ul> <li>This example uses an enum, but it can be any Object; the GraphQL client     calls <code>toString()</code> to convert it.</li> </ul> <p>The method must be <code>static</code> and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot <code>\".\"</code>, e.g. <code>@Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\")</code>.</p> <p>A third option is to pass the value of a header as an API method parameter:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    List&lt;SuperHero&gt; allHeroesIn(String location, @Header(name = \"S.H.I.E.L.D.-Clearance\") Clearance clearance);\n}\n</code></pre> <p>The <code>@Header</code> parameter will not be part of the GraphQL query.</p> <p>The <code>name</code> of the header is always static, but can optionally be derived from the name of the parameter or method, i.e. if it has a <code>@Name</code> annotation, that annotation value is used. If it's not annotated, the method name (eventually stripped off a leading <code>get</code>) or the parameter name (if it's enabled in the compiler settings) is converted from camel case to kebab case, i.e. a parameter <code>@Header String requestIdentifier</code> will result in a header named <code>Request-Identifier</code>.</p> <p><code>@Header</code> annotations can also be defined via <code>@Stereotype</code>.</p> <p>When instantiating the API with the builder, you can set (or overwrite) one or more headers there:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder()\n    .header(\"S.H.I.E.L.D.-Clearance\", \"TOP-SECRET\")\n    .build(SuperHeroesApi.class);\n</code></pre>"},{"location":"typesafe-client-headers/#authorization-headers","title":"Authorization headers","text":"<p>To add an <code>Authorization</code> header, instead of using the generic <code>@Header</code> annotation, you can also use the special <code>@AuthorizationHeader</code> annotation. It produces a <code>BASIC</code> <code>Authorization</code> header by default or a <code>BEARER</code> token. You can configure the credentials in MP Config with a prefix plus <code>/mp-graphql/</code> and either <code>username</code> and <code>password</code> for <code>BASIC</code> or <code>bearer</code> for <code>BEARER</code>. The config key defaults to the fully qualified name of the <code>GraphQLClientApi</code> interface or its <code>configKey</code>.</p> <p>You can use a custom prefix by setting the <code>confPrefix</code>. The infix <code>/mp-graphql/</code> is still applied, unless you end the <code>confPrefix</code> with <code>*</code>, e.g. <code>@AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.*</code> will use <code>org.superheroes.security.basic.username</code>, while <code>*</code> will use plain <code>username</code>.</p> <p><code>@AuthorizationHeader</code> annotations can be defined via <code>@Stereotype</code>.</p>"},{"location":"typesafe-client-logging/","title":"Logging in typesafe clients","text":"<p>The Client implementation logs all GraphQL requests and responses at level <code>INFO</code> with the interface API as the logger name. It also logs the keys of all headers added at level <code>DEBUG</code>; not the values, as they may be security sensitive.</p>"},{"location":"typesafe-client-multiple-queries/","title":"Multiple","text":"<p>Say you need the result from several root queries, e.g. all <code>superHeroes</code> and all <code>superVillains</code>. Java only supports a single return value, so you\u2019ll need a wrapper class:</p> <pre><code>@GraphQLClientApi\ninterface SuperHeroesApi {\n    HeroesAndVillains heroesAndVillains();\n}\n\n@Multiple\nclass HeroesAndVillains {\n    List&lt;SuperHero&gt; superHeroes;\n    List&lt;SuperVillain&gt; superVillains;\n}\n</code></pre> <p>The <code>@Multiple</code> annotation 'inlines' the wrapper class, i.e. the actual query is:</p> <pre><code>query heroesAndVillains { superHeroes {...} superVillains {...}}\n</code></pre> <p>The actual response below will be mapped to an instance of the <code>HeroesAndVillains</code> wrapper class:</p> <pre><code>{\n  \"data\": {\n    \"superHeroes\": [ ... ],\n    \"superVillains\": [ ... ]\n  }\n}\n</code></pre> <p>If the nested queries require parameters, use <code>@</code> annotations to put them on the field (remember: GraphQL fields can have parameters).</p> <p>If you need the same request several times (e.g. with different query parameters), use <code>@Name</code> annotations, so the actual field names are used as alias.</p>"},{"location":"typesafe-client-reactive-types/","title":"Reactive types usage in typesafe clients","text":""},{"location":"typesafe-client-reactive-types/#reactive-types-with-queries-and-mutations","title":"Reactive types with queries and mutations","text":"<p>Regardless of the type that a query or mutation returns, you can always wrap the return type in a <code>Uni</code> in your <code>@GraphQLClientApi</code> interface. The <code>Uni</code> will be completed after the response is received and processed.</p>"},{"location":"typesafe-client-reactive-types/#subscriptions","title":"Subscriptions","text":"<p>The return type of a subscription operation must always be wrapped in a <code>Multi</code>. The communication with the server runs over a WebSocket.</p>"},{"location":"typesafe-client-reactive-types/#important-note-about-errors","title":"Important note about errors","text":"<p>When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an <code>ErrorOr</code> (for example, turn the API method <code>@Subscription Multi&lt;Person&gt; people</code> into <code>@Subscription Multi&lt;ErrorOr&lt;Person&gt;&gt; people</code>). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the <code>Multi</code> will receive a failure as a result. Because of the design of Mutiny, a <code>Multi</code> can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use <code>ErrorOr</code>.</p>"},{"location":"typesafe-client-reactive-types/#subscription-example","title":"Subscription example","text":"<p>Given a server-side definition like this:</p> <pre><code>@Subscription\npublic Multi&lt;Integer&gt; countToFive() {\n    return Multi.createFrom().range(0, 5);\n}\n</code></pre> <p>A client to consume this subscription can look like this: <pre><code>client.countToFive\n    .subscribe()\n    .with( // onItem:\n        i -&gt; System.out.println(\"Received number\" + i),\n        // onFailure:\n        (t) -&gt; t.printStackTrace()\n    );\n</code></pre></p>"},{"location":"typesafe-client-usage/","title":"Basic usage","text":"<p>A Java code-first type-safe GraphQL Client API suggestion for Microprofile GraphQL Issue #185.</p>"},{"location":"typesafe-client-usage/#basic-usage","title":"Basic Usage","text":"<p>Creating the client-side counterpart of the GraphQL API:</p> <pre><code>package examples.typesafeclient;\n\nimport io.smallrye.graphql.client.typesafe.api.GraphQLClientApi;\n\nimport java.util.List;\n\n@GraphQLClientApi\npublic interface SuperHeroesApi {\n\n    List&lt;SuperHero&gt; allHeroesIn(String location);\n\n}\n</code></pre> <p>A model class:</p> <pre><code>package examples.typesafeclient;\n\nimport java.util.List;\n\npublic class SuperHero {\n\n    private String name;\n    private List&lt;String&gt; superPowers;\n\n    // plus getters and setters\n\n}\n</code></pre> <p>Injecting the client using CDI and using it:</p> <pre><code>package examples.typesafeclient;\n\nimport javax.inject.Inject;\nimport java.util.List;\n\npublic class MyClientUsage {\n\n    @Inject\n    SuperHeroesApi superHeroesApi;\n\n    public void execute() {\n        List&lt;SuperHero&gt; allHeroes = superHeroesApi.allHeroesIn(\"Outer Space\");\n        // ...\n    }\n\n}\n</code></pre> <ul> <li>The default request type is <code>query</code>. To make it a mutation, annotate     it <code>@Mutation</code>. The parameter name is only available if you compile     the source with the <code>-parameters</code> option. Otherwise, you\u2019ll have to     annotate all parameters with <code>@Name</code>.</li> </ul> <p>The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder().build(SuperHeroesApi.class);\n</code></pre> <p>The basic idea of the Java code-first approach is that you start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts.</p> <p>If the server uses names different from yours, you can simply use annotations to do a mapping:</p>"},{"location":"typesafe-client-usage/#name-mapping-aliases","title":"Name Mapping / Aliases","text":"<p>If the server defines a different field or parameter name, annotate it with <code>@Name</code>. If the server defines a different query name, annotate the method as, e.g., <code>@Query(\"findHeroesCurrentlyLocatedIn\")</code>.</p> <p>By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.:</p> <pre><code>public interface SuperHeroesApi {\n    SuperHero findHeroByName(String name); \n\n    @Query(\"findHeroByName\")\n    SuperHeroWithTeams findHeroWithTeamsByName(String name); \n}\n</code></pre> <ul> <li> <p>The <code>SuperHero</code> class has no team affiliations (for this example).</p> </li> <li> <p>The <code>SuperHeroWithTeams</code> class has a <code>List&lt;Team&gt; teamAffiliations</code>     field. The actual query name is still <code>findHeroByName</code>. The <code>Team</code>     class doesn\u2019t contain the members to break recursion.</p> </li> </ul> <p>If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see <code>and</code> below).</p>"},{"location":"typesafe-client-usage/#configuration","title":"Configuration","text":"<p>If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.:</p> <pre><code>@GraphQLClientApi(endpoint = \"https://superheroes.org/graphql\")\ninterface SuperHeroesApi {\n}\n</code></pre> <p>When instantiating the API with the builder, you can set (or overwrite) the endpoint there:</p> <pre><code>SuperHeroesApi api = TypesafeGraphQLClientBuilder.newBuilder()\n    .endpoint(\"https://superheroes.org/graphql\")\n    .build(SuperHeroesApi.class);\n</code></pre> <p>Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client, the key for the endpoint is the fully qualified name of the api interface, plus <code>/mp-graphql/url</code>, e.g.:</p> <pre><code>org.superheroes.SuperHeroesApi/mp-graphql/url=https://superheroes.org/graphql\n</code></pre> <p>If you want to use a different key, set the base config key on the annotation <code>@GraphQLClientApi(configKey = \"superheroes\")</code>; then use this key for the endpoint <code>superheroes/mp-graphql/url</code>.</p> <p>When using the builder, you can override the config key as well: <code>TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\")</code>.</p>"},{"location":"typesafe-client-usage/#nestedparameter","title":"NestedParameter","text":"<p>Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this:</p> <pre><code>type Query {\n    team(name: String!): Team!\n}\n\ntype Team {\n    members(first: Int!): [SuperHero!]!\n}\n</code></pre> <p>To pass the parameter to the nested field/method, annotate it as <code>@NestedParameter</code>, e.g.:</p> <pre><code>@GraphQLClientApi\ninterface TeamsApi {\n    Team team(String name, @NestedParameter(\"members\") int first);\n}\n</code></pre> <p>The value of the <code>@NestedParameter</code> annotation is the dot-delimited path to the nested field/method that the value should be added to.</p>"},{"location":"using-smallrye-stork/","title":"Using SmallRye Stork","text":"<p>SmallRye GraphQL client (both dynamic and typesafe) supports SmallRye Stork for  service discovery and load balancing. If your client is configured to connect to a URI with the <code>stork://</code> or <code>storks://</code> scheme, then Stork will be used to determine the actual endpoints to connect to. Load balancing, if configured, will be applied in a way that each HTTP request can be routed to a different service instance. For WebSocket traffic, once a WebSocket connection is established, the client will keep using that connection for as long as possible. If that connection is lost for any reason and needs to be reestablished, then the load balancer can route it to a different instance.</p>"},{"location":"using-smallrye-stork/#using-with-quarkus","title":"Using with Quarkus","text":"<p>The dependency on Stork is declared as optional, so if you want to use it, you might need  to add it explicitly. If you're using Quarkus, use the Stork extension along with  the desired service discovery implementation, for example:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-smallrye-stork&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-stork-service-discovery-static-list&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Example configuration in Quarkus <code>application.properties</code>: <pre><code>quarkus.smallrye-graphql-client.myclient.url=stork://foo-service/graphql\nquarkus.stork.foo-service.service-discovery.type=static\nquarkus.stork.foo-service.service-discovery.address-list=server1.com:8080,server2.com:8080\n</code></pre></p>"},{"location":"using-smallrye-stork/#when-running-as-a-standalone-application","title":"When running as a standalone application","text":"<p>If you're using the client in a standalone mode outside any container that handles Stork initialization for you, you might need two additional steps to get it working:</p> <p>Add a configuration provider for Stork, such as <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-microprofile-config&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>And before initializing any GraphQL client instances, make sure that Stork is initialized  by calling <code>io.smallrye.stork.Stork.initialize()</code> once.</p>"}]}